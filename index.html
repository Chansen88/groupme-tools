<!DOCTYPE html>
<meta charset="utf-8">
<title>Streamgraph</title>
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: auto;
  position: relative;
  width: 100%;
}

</style>
<body></body>
<script src="d3.v3.min.js"></script>
<!-- http://bl.ocks.org/mbostock/4060954 -->
<script>

var width = document.body.clientWidth,
    height = 600;

var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var color = d3.scale.linear()
    .range(["#aad", "#556"]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);



d3.json('transcript-4218561.json', function(error, rawdata) {
  // only analyze part of data
  rawdata = rawdata.slice(0, 200);
  
  // first get dates
  // rawdata.split('\n').forEach(function(d) {
  rawdata.forEach(function(d) {
    d.date = new Date(new Date(d.created_at*1000).toDateString());
  });

  
  
  // get range
  // x.domain([d3.min(rawdata, function(d) { return d.date }), new Date()]);
  x.domain(d3.extent(rawdata, function(d) { return d.date; }));
  // you don't actually have this data until later
  // y.domain([0, 40]);
  console.log(x.domain());


  // then nest
  var nest = d3.nest()
      .key(function(d) { return d.name; })
      .key(function(d) { return d.date.toDateString(); })
      .entries(rawdata);
  // don't need groupme      
  // nest = nest.slice(1, nest.length);
  

  // ndata = []
  nest.forEach(function(person) {
    for(var d = x.domain()[0]; d <= x.domain()[1]; d.setDate(d.getDate() + 1)) {
      // person talked on this day?
      var hasDate = false;
      person.values.forEach(function(pd) {
        if(pd.key == d.toDateString()) {
          hasDate = true;
          // anyway to break out?
        }
      });
      // if not add in empty
      if(!hasDate) {
        var empty = Object();
        empty.key = d.toDateString();
        empty.values = [];
        empty.pushed = true;
        person.values.push(empty);
      }
    }
  });
  // sort each layers values so it doesn't fuck up
  nest.forEach(function(layer) {
    layer.values.sort(function(a, b){
      return new Date(a.key) - new Date(b.key);
    });
  });

  
  // incase you want to limit the people you're analyzing
  // nest = nest.slice(0, 3);
  console.log(nest);


  var stack = d3.layout.stack().offset("wiggle")
      .x(function(d) { return new Date(d.key); })
      .y(function(d) { return d.values.length; })
      .values(function(d) { return d.values; })
  
  var layers = stack(nest);
  
  var area = d3.svg.area()
      .interpolate("basis") 
      .x(function(d) { return x(new Date(d.key)); })
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  svg.selectAll(".layers")
      .data(layers)
    .enter().append("path")
      .attr("class", "layer")
      .attr("id", function(d) { return d.key; })
      .attr("d", function(d) { return area(d.values); })
      .style("fill", function(d, i) { return color(i * 1.0/layers.length); });

  
  // fix theres a duplicate point to bottom left corner
  // how you tried to fix it


  // remove those duplicate things in svg????
  // var elements = document.getElementsByClassName("layer");
  // for(var i=0;i < elements.length; i++) {
  //   var pathd = elements.item(i).getAttribute("d");
  //   var match = pathd.match(/(L[0-9\.]+,[0-9\.]+).+\1/)[0];
  //   elements.item(i).setAttribute("d", pathd.replace(match, ""));
  // }
  
  // var myarea = function(array) {
  //   var results = "M" + 0 + ", " + height;

  //   for(var i=0;i < array.length;i++) {
  //     var d = array[i];
  //     var point = "L" + x(new Date(d.key)) + "," + y(d.y0 + d.y);
  //     console.log(d.key + " " + (d.y0 + d.y) + " " + point);
  //     // console.log(point);
  //     results += point;
  //   }

  //   // now go reverse and fill in the opposite side
  //   for(var i=array.length - 1;i >= 0;i--) {
  //     var d = array[i];
  //     results += "L" + x(new Date(d.key)) + "," + y(d.y0);
  //   }

  //   return results + "Z";
  // }
});



function transition() {
  d3.selectAll("path")
      .data(function() {
        var d = layers1;
        layers1 = layers0;
        return layers0 = d;
      })
    .transition()
      .duration(2500)
      .attr("d", area);
}




</script>